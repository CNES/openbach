#!/usr/bin/env python3

# OpenBACH is a generic testbed able to control/configure multiple
# network/physical entities (under test) and collect data from them. It is
# composed of an Auditorium (HMIs), a Controller, a Collector and multiple
# Agents (one for each network entity that wants to be tested).
#
#
# Copyright © 2016-2020 CNES
#
#
# This file is part of the OpenBACH testbed.
#
#
# OpenBACH is a free software : you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program. If not, see http://www.gnu.org/licenses/.


"""Provide time period summary of data generated by OpenBACH jobs"""


__author__ = 'Viveris Technologies'
__credits__ = '''Contributors:
 * Aichatou Garba Abdou <aichatou.garba-abdou@viveris.fr>
'''

import os
import itertools
import tempfile
import argparse
from dateutil.parser import parse
from datetime import datetime,timedelta
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

#import collect_agent
from data_access.post_processing import Statistics, save, _Plot

UNIT_OPTION={'s', 'ms' ,'bits/s', 'Kbits/s', 'Mbits/s','Gbits/s','Bytes' ,'KBytes', 'MBytes', 'GBytes'}
FUNCTION_OPTION={'moyenne','mediane','min','max'}
function_option={'moyenne':'Moyenne','mediane':'Médiane','min':'Minimum','max':'Maximum'}
def multiplier(base, unit):
        if unit == base:
                return 1
        if unit.startswith('GBytes'):
                return 1024 * 1024 * 1024
        if unit.startswith('MBytes'):
                return 1024 * 1024
        if unit.startswith('KBytes'):
                return 1024
        if unit.startswith('m'):
                return 0.001
        if unit.startswith('s'):
                return 1000
        if unit.startswith('Gbits'):
                return 1000 * 1000 * 1000
        if unit.startswith('Mbits'):
                return 1000 * 1000
        if unit.startswith('Kbits'):
                return 1000

        return 1
def main(
        agent_name,agents_title,job_name, statistics_names,functins,begin_date,num_bars,end_date,start_journey,start_evening,start_night,reference,
        stat_units,table_units,stat_title, stats_with_suffixes):


    file_ext = 'png'
    statistics=Statistics('172.20.34.80')
    #statistics = Statistics.from_default_collector()
    statistics.origin = 0
    with tempfile.TemporaryDirectory(prefix='openbach-summary_time_period-') as root:

        
         for agents,agents_title,job,fields,function,begin_date,num_bar,end_date,start_journey,start_evening,start_night,reference,stat_unit,table_unit,stat_title in itertools.zip_longest(
            agent_name,agents_title,job_name, statistics_names,functins,begin_date,num_bars,end_date,start_journey,start_evening,start_night,reference,stat_units,table_units,stat_title,
             fillvalue=[]):

            if len(begin_date) > 1 :
                begin_date=' '.join(begin_date)
            if len(end_date) > 1:
                end_date = ' '.join(end_date)

            if not begin_date and not end_date:
                timestamp=None
            else:
                begin_date=parse(begin_date)
                end_date=parse(end_date)
                timestamp=[int(datetime.timestamp(begin_date)*1000),int(datetime.timestamp(end_date)*1000)]

            metadata=itertools.zip_longest(job,fields,function,num_bar,start_journey,start_evening,start_night,reference,stat_unit,table_unit,stat_title)
            
            for job,field,function,num_bar,start_journey,start_evening,start_night,reference,stat_unit,table_unit,stat_title  in metadata:
                
                
                if num_bar is None:
                   num_bar=5

                if  stat_title is None:
                    stat_title=field
        
                if  table_unit is None:
                        table_unit=''
               
                facteur=multiplier(stat_unit,table_unit)
                
                if  function is None:
                   function='moyenne'

                nrows=len(agents)
                figure, axis = plt.subplots(nrows+1,4)
                plt.subplots_adjust(hspace=0,wspace=0)
                _list=list(axis)
                first_axe=_list[0]
                moments=[f' {function_option[function]} \n {stat_title} \n {table_unit}','Journée','Soirée','Nuit']
                for moment,ax in zip(moments,first_axe): 
                  ax.axis([0, 10, 0, 10])   
                  ax.text(.5,3,moment,fontsize=10)

                for axe in axis.flat:
                        axe.tick_params(
                                        which='both',      
                                        bottom=False,
                                        left=False,      
                                        top=False,  
                                        labelleft = False,       
                                        labelbottom=False)

                if not agents_title:
                   agents_title=agents

                for (index, agent),agent_title in itertools.zip_longest(enumerate(agents),agents_title,fillvalue=None):
                        
                        if agent_title is None:
                                agent_title=agent
                        data_collection = statistics.fetch(
                                job=job,agent=agent,
                                suffix = None if stats_with_suffixes else '',
                                fields=fields,timestamps=timestamp)  
                        df = pd.concat([
                        plot.dataframe.set_axis(plot.dataframe.columns.get_level_values('statistic'), axis=1, copy=False)
                        for plot in data_collection])
        
                        df.columns = pd.MultiIndex.from_tuples(
                        [('', '', '', '', stat) for stat in df.columns],
                        names=['job', 'scenario', 'agent', 'suffix', 'statistic'])
                        if field not in df.columns.get_level_values('statistic'):
                                message = 'job  {} did not produce the statistic {}'.format(job, field)
                                #collect_agent.send_log(syslog.LOG_WARNING, message)
                                print(message)
                        plot = _Plot(df)
                        axes=plot.plot_summary_agent_comparison(_list[index+1],fields,function,facteur,reference,agent_title,num_bar,
                                                                start_journey=7 if not start_journey else start_journey,
                                                                start_evening=18 if not start_evening else start_evening,
                                                                start_night=0 if not start_night else start_night)

                filepath = os.path.join(root, 'summary_agent_comparison_{}.{}'.format(field, file_ext))
                save(figure,'/home/agarba-abdou/summary_agent_comparison_{}.{}'.format(field, file_ext),set_legend=False)
                #collect_agent.store_files(collect_agent.now(), figure=filepath)
                   



if __name__ == '__main__':
    #with collect_agent.use_configuration('/opt/openbach/agent/jobs/temporal_binning_histogram/temporal_binning_histogram_rstats_filter.conf'):
        parser = argparse.ArgumentParser(description=__doc__)
        parser.add_argument(
                '-n', '--agent', metavar='AGENT_NAME', nargs='+', action='append',dest='agents',
                required=True, type=str, default=[],
                help='Agent name to fetch data from')
        parser.add_argument(
                '-a', '--agent-title', metavar='AGENT_TITLE ', nargs='+', action='append',dest='agents_title',
                type=str, default=[],help='Agent name to display on the table')
        parser.add_argument(
                '-j', '--jobs', metavar='JOB_NAME', nargs='+', action='append',
                required=True, type=str, default=[],dest='jobs',
                help='job name to fetch data from')
        parser.add_argument(
                '-s', '--stat', '--statistic', dest='statistics',
                metavar='STATISTIC', nargs='+', action='append', default=[],
                help='statistics names to be analysed')
        parser.add_argument(
                '-f', '--function', dest='function',choices=FUNCTION_OPTION,
                metavar='FUNCTION', nargs='+', action='append', default=[],
                help='Mathematical function to compute')
        parser.add_argument(
                '-b', '--begin-date',metavar='BIGIN_DATE',nargs='+' ,dest='begin_date',
                default=[],help='Start date in form YYYY:MM:DD hh:mm:ss', action='append')
        parser.add_argument(
                '-nb', '--num-bars',metavar='NUM_BARS',nargs='+' ,dest='num_bars',type=int,default=[],
                help='Number of reception bars', action='append')
        parser.add_argument(
                '-e', '--end-date',metavar='END_DATE',nargs='+' ,dest='end_date',
                default=[],help='End date in form YYYY:MM:DD hh:mm:ss', action='append')

        parser.add_argument(
                '-sj', '--start-journey',metavar='START_JOURNEY',nargs='+' ,dest='start_journey',
                default=[],help='starting time of the day', action='append')
        parser.add_argument(
                '-se', '--start-evening',metavar='START_EVENING',nargs='+' ,dest='start_evening',
                default=[],help='starting time of the evening', action='append')
        parser.add_argument(
                '-sn', '--start-night',metavar='START_NIGHT',nargs='+' ,dest='start_night',
                default=[],help='starting time of the night', action='append')
        parser.add_argument(
                '-r', '--reference',metavar='REFERENCE',nargs='+' ,dest='reference',type=int,
                default=[],help='Reference value for comparison', action='append')
        parser.add_argument(
                '-ub', '--stat-unit', dest='stat_units', nargs='+',choices=UNIT_OPTION,
                metavar='STAT_UNIT', action='append', default=[],
                help='Unit of the statistic')
        parser.add_argument(
                '-u', '--table-unit', dest='table_units', nargs='+',choices=UNIT_OPTION,
                metavar='TALE_UNIT', action='append', default=[],
                help='Unit to show on the table')
        parser.add_argument(
                '-t', '--stat-title', '--stat-title', dest='stat_title',
                metavar='STAT-TITLE', nargs='+', action='append', default=[],
                help='statistics names to display on the table')
        parser.add_argument(
                '-w', '--no-suffix', action='store_true',
                help='Do not plot statistics with suffixes')

        args = parser.parse_args()
        stats_with_suffixes = not args.no_suffix
        

        main(
            args.agents,args.agents_title,args.jobs, args.statistics,args.function,args.begin_date,args.num_bars,args.end_date,args.start_journey,args.start_evening,
            args.start_night,args.reference,args.stat_units,args.table_units,args.stat_title ,stats_with_suffixes)

