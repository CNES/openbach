#!/usr/bin/env python3
# -*- coding: utf-8 -*-

#  OpenBACH is a generic testbed able to control/configure multiple
#  network/physical entities (under test) and collect data from them. It is
#  composed of an Auditorium (HMIs), a Controller, a Collector and multiple
#  Agents (one for each network entity that wants to be tested).
#
#
#  Copyright Â© 2016-2020 CNES
#
#
#  This file is part of the OpenBACH testbed.
#
#
#  OpenBACH is a free software : you can redistribute it and/or modify it under
#  the terms of the GNU General Public License as published by the Free
#  Software Foundation, either version 3 of the License, or (at your option)
#  any later version.
#
#  This program is distributed in the hope that it will be useful, but WITHOUT
#  ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
#  more details. # # You should have received a copy of the GNU General Public License along with
#  this program. If not, see http://www.gnu.org/licenses/.


"""Sources of the Job d-itg_send"""


__author__ = 'CNES'
__credits__ = '''Contributor: Guillaume Colombo <guillaume.colombo@cnes.fr>
              Matthieu Petrou <matthieu.petrou@viveris.fr>
              '''

import os
import sys
import time
import syslog
import argparse
import traceback
import subprocess
import contextlib

import collect_agent

@contextlib.contextmanager
def use_configuration(filepath):
    success = collect_agent.register_collect(filepath)
    if not success:
        message = 'ERROR connecting to collect-agent'
        collect_agent.send_log(syslog.LOG_ERR, message)
        sys.exit(message)
    collect_agent.send_log(syslog.LOG_DEBUG, 'Starting job ' + os.environ.get('JOB_NAME', '!'))
    try:
        yield
    except Exception:
        message = traceback.format_exc()
        collect_agent.send_log(syslog.LOG_CRIT, message)
        raise
    except SystemExit as e:
        if e.code != 0:
            collect_agent.send_log(syslog.LOG_CRIT, 'Abrupt program termination: ' + str(e.code))
        raise


def run_command(cmd, mode='run'):
    try:
        if mode == 'Popen':
            p = subprocess.Popen(cmd, stderr=subprocess.PIPE)
        else:
            p = subprocess.run(cmd, stderr=subprocess.PIPE)
    except Exception as ex:
        message = 'Error running {} : {}'.format(cmd, ex)
        collect_agent.send_log(syslog.LOG_ERR, message)
        sys.exit(message)

    return p


def main(target_address, log_address, dest_path, granularity, traffic_type='UDP', port=8999, signal_port=9000,
         packet_size=512, packet_rate=1000, bandwidth='0', duration=10, data_size='0', meter='rttm'):

    # Clean previous log and set up the D-ITG LogServer*
    if os.path.isfile('/tmp/ITGRecv.log'):
        os.remove('/tmp/ITGRecv.log')
    if os.path.isfile('/tmp/ITGSend.log'):
        os.remove('/tmp/ITGSend.log')

    proc_log = run_command('ITGLog', 'Popen')

    # Get the reference time for changing the stats generated by D-ITG
    time_ref = int(round(time.time() * 1000))

    #Set packet_rate depending on bandwidth parameter
    if bandwidth != '0':
        if 'K' == 'K' in bandwidth:
            packet_rate = 1000 * int(bandwidth.replace('K',''))
        elif 'M' == 'M' in bandwidth:
            packet_rate = 1000 * 1000 * int(bandwidth.replace('M',''))
        elif 'G' == 'G' in bandwidth:
            packet_rate = 1000 * 1000 * 1000 * int(bandwidth.replace('G',''))
        else:
            packet_rate = int(bandwidth)
        packet_rate = packet_rate/(8 * packet_size)

    # Build and launch the D-ITGSend command
    cmd_send = ['ITGSend', '-a', target_address, '-L', log_address, '-X', log_address,
             '-T', traffic_type, '-c', str(packet_size), '-C', str(packet_rate), '-t', str(duration*1000),
             '-m', meter, '-Sdp', str(signal_port), '-Ssp', str(signal_port), '-rp', str(port)]
   
    #Set number of KBytes to generate
    if data_size != '0':
        if 'M' == 'M' in data_size:
            data_size_f = 1024 * float(data_size.replace('M',''))
        elif 'G' == 'G' in data_size:
            data_size_f = 1024 * 1024 * float(data_size.replace('G',''))
        else:
            data_size_f = float(data_size.replace('K',''))
        cmd_send.extend(['-k', str(data_size_f)])

    run_command(cmd_send)

    # Terminate the process of the D-ITG LogServer
    proc_log.terminate()

    # Clear potential old stats
    if os.path.isfile(os.path.join(dest_path, 'RCV')):
        os.remove(os.path.join(dest_path, 'RCV'))
    if os.path.isfile(os.path.join(dest_path, 'SND')):
        os.remove(os.path.join(dest_path, 'SND'))

    # Get the stats from the logs
    cmd_rcv_cb = ['ITGDec', '/tmp/ITGRecv.log', '-c', str(granularity), os.path.join(dest_path, 'RCV')]
    run_command(cmd_rcv_cb)
    cmd_snd_cb = ['ITGDec', '/tmp/ITGSend.log', '-c', str(granularity), os.path.join(dest_path, 'SND')]
    run_command(cmd_snd_cb)

    # Send the stats of the receiver to the collector
    path_RCV = os.path.join(dest_path, 'RCV')

    try:
        stats = open(path_RCV, "r")
    except Exception as ex:
        message = 'Error opening file {} : {}'.format(path_RCV, ex)
        collect_agent.send_log(syslog.LOG_ERR, message)
        sys.exit(message)
    
    owd_r = []
    with stats :
        for line in stats:
            txt = line.strip()
            txt = txt.split(' ')

            # Get the timestamp (in ms)
            timestamp = txt[0].replace('.','')
            timestamp = int(timestamp[:-3])
            timestamp = timestamp + time_ref

            # Get the bitrate (in bps)
            bitrate = txt[1]
            bitrate = float(bitrate)*1024
            statistics = {'bitrate_receiver': bitrate}
            collect_agent.send_stat(timestamp, **statistics)

            # Get the delay (in ms)
            delay = txt[2]
            delay = float(delay)*1000
            owd_r.append(delay)
            statistics = {'owd_receiver': delay}
            collect_agent.send_stat(timestamp, **statistics)

            # Get the jitter (in ms)
            jitter = txt[3]
            jitter = float(jitter)*1000
            statistics = {'jitter_receiver': jitter}
            collect_agent.send_stat(timestamp, **statistics)

            # Get the packetloss
            pck_loss = txt[4]
            pck_loss = float(pck_loss)
            statistics = {'packetloss_receiver': pck_loss}
            collect_agent.send_stat(timestamp, **statistics)

            # Calculate packet_loss_rate
            plr = (pck_loss/packet_rate)*100
            statistics = {'packetloss_rate_receiver': plr}
            collect_agent.send_stat(timestamp, **statistics)

    # Send the stats of the sender to the collector
    path_SND = os.path.join(dest_path, 'SND')

    try:
        stats = open(path_SND, "r")
    except Exception as ex:
        message = 'Error opening file {} : {}'.format(path_SND, ex)
        collect_agent.send_log(syslog.LOG_ERR, message)
        sys.exit(message)

    owd_s = []
    timetab = []

    with stats:
        for line in stats:
            txt = line.strip()
            txt = txt.split(' ')
    
            # Get the timestamp (in ms)
            timestamp = txt[0].replace('.','')
            timestamp = int(timestamp[:-3])
            timestamp = timestamp + time_ref
    
            # Get the bitrate (in bps)
            bitrate = txt[1]
            bitrate = float(bitrate)*1024
            statistics = {'bitrate_sender': bitrate}
            collect_agent.send_stat(timestamp, **statistics)
    
            if meter.upper() == "RTTM":
                # Get the delay (in ms)
                delay = txt[2]
                delay = float(delay)*1000
                owd_s.append(delay)
                timetab.append(timestamp)
                statistics = {'rtt_sender': delay}
                collect_agent.send_stat(timestamp, **statistics)
    
                # Get the jitter (in ms)
                jitter = txt[3]
                jitter = float(jitter)*1000
                statistics = {'jitter_sender': jitter}
                collect_agent.send_stat(timestamp, **statistics)
    
                # Get the packetloss
                pck_loss = txt[4]
                pck_loss = float(pck_loss)
                statistics = {'packetloss_sender': pck_loss}
                collect_agent.send_stat(timestamp, **statistics)        

                # Calculate packet_loss_rate
                plr = (pck_loss/packet_rate)*100
                statistics = {'packetloss_rate_sender': plr}
                collect_agent.send_stat(timestamp, **statistics)

    if meter.upper() == 'RTTM':
        for time_tab, owdr, owds in zip(timetab, owd_r, owd_s):
          owd_return = owds - owdr
          statistics = {'owd_return': owd_return}
          collect_agent.send_stat(time_tab, **statistics)
        

    
if __name__ == "__main__":
    with use_configuration("/opt/openbach/agent/jobs/d-itg_send/d-itg_send_rstats_filter.conf"):
        # Define Usage
        parser = argparse.ArgumentParser(description='Create a D-ITG command',
                                         formatter_class=argparse.ArgumentDefaultsHelpFormatter)
        parser.add_argument('target_address', type=str, metavar='Target_address',
                            help='Address IP where the flow is sent')
        parser.add_argument('sender_address', type=str,  metavar='sender_address',
                            help="Address of the sender to get the receiver's logs")
        parser.add_argument('dest_path', type=str, metavar='Destination_path',
                            help='Path where the stats will be located')
        parser.add_argument('granularity', type=int, metavar='Granularity',
                            help='Set the granularity (in ms) at which the stats will be generated')
        parser.add_argument('-T', '--traffic_type', type=str, metavar='TRAFFIC TYPE', default='UDP', 
                            help='Traffic type (UDP, TCP, ICMP, ...) (default=UDP)')
        parser.add_argument('-p', '--port', type=int, metavar='PORT', default=8999,
                            help='Set server port (default=8999)')
        parser.add_argument('-P', '--signal_port', type=int, metavar='SIGNAL PORT', default=9000,
                            help='Set port for signal transmission (default=9000)')
        parser.add_argument('-c', '--packet_size', type=int, metavar='PACKET SIZE',
                            help='Size of each packet in byte default=512', default = 512)
        parser.add_argument('-C', '--packet_rate', type=int, metavar='PACKET RATE', default=1000,
                            help='Number of packets to send in one second (default=1000)')
        parser.add_argument('-B', '--bandwidth', type=str, metavar='BANDWIDTH',
                            help='Set bandwidth in [K/M/G]bits/s, if set will overrun packet_rate (default=0)', default='0')
        parser.add_argument('-d', '--duration', type=int, metavar='DURATION',
                            help='Duration of the traffic in s (default=10)', default=10)
        parser.add_argument('-k', '--data_size', type=str, metavar='DATA SIZE', default='0',
                            help='Set the number of [K/M/G]Bytes to send, if set either duration or data_size will limit the job')
        parser.add_argument('-m', '--meter', type=str, metavar='METER', choices=['owdm', 'rttm'], 
                            help='Way to compute the time: One Way Delay (owdm) or Round Trip Time (rttm) (default=rttm)',
                            default='rttm')

        # get args
        args = parser.parse_args()
        target_address = args.target_address
        sender_address = args.sender_address
        dest_path = args.dest_path
        granularity = args.granularity
        traffic_type = args.traffic_type
        port = args.port
        signal_port = args.signal_port
        packet_size = args.packet_size
        packet_rate = args.packet_rate
        bandwidth = args.bandwidth
        duration = args.duration
        data_size = args.data_size
        meter = args.meter
   
        main(target_address, sender_address, dest_path, granularity, traffic_type, port, signal_port, packet_size, packet_rate, bandwidth, duration, data_size, meter)

