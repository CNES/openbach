# OpenBACH is a generic testbed able to control/configure multiple
# network/physical entities (under test) and collect data from them. It is
# composed of an Auditorium (HMIs), a Controller, a Collector and multiple
# Agents (one for each network entity that wants to be tested).
#
#
# Copyright Â© 2016-2023 CNES
#
#
# This file is part of the OpenBACH testbed.
#
#
# OpenBACH is a free software : you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program. If not, see http://www.gnu.org/licenses/.


"""Table descriptions relatives to the OpenBACH's jobs.

Each class in this module describe a table with its associated
columns in the backend's database. These classes are used by
the Django's ORM to convert results from databases queries into
Python objects.
"""


__author__ = 'Viveris Technologies'
__credits__ = '''Contributors:
 * Adrien THIBAUD <adrien.thibaud@toulouse.viveris.com>
 * Mathias ETTINGER <mathias.ettinger@toulouse.viveris.com>
'''


from itertools import chain
from datetime import datetime

from django.db import models, IntegrityError
from django.utils import timezone
from django.contrib.auth.models import User

from .base_models import Argument, ArgumentValue, ValuesType
from .utils import subcommand_storage


class Keyword(models.Model):
    """Keyword associated to a Job"""
    name = models.CharField(max_length=500, primary_key=True)

    def __str__(self):
        return self.name


class Job(models.Model):
    """Data associated to a Job"""

    name = models.CharField(max_length=500, primary_key=True)
    path = models.FilePathField(
            path="/opt/openbach/controller/src/jobs",
            max_length=500, recursive=True,
            allow_folders=True, allow_files=False)
    help = models.TextField(null=True, blank=True)
    job_version = models.CharField(max_length=500, null=True, blank=True)
    description = models.TextField(null=True, blank=True)
    keywords = models.ManyToManyField(Keyword, related_name='jobs')
    persistent = models.BooleanField(default=False)

    def __str__(self):
        return self.name

    @property
    def json(self):
        return {
                'general': {
                    'name': self.name,
                    'description': self.description,
                    'job_version': self.job_version,
                    'keywords': [keyword.name for keyword in self.keywords.all()],
                    'persistent': self.persistent,
                },
                'platform_configuration': [system.json for system in self.os.all()],
                'arguments': self.subcommands.get(group=None).json,
                'statistics': [stat.json for stat in self.statistics.all()],
        }


class OsCommand(models.Model):
    """Data relative to how a job should be launched/cleaned-up on a given OS"""

    job = models.ForeignKey(Job, models.CASCADE, related_name='os')
    family = models.CharField(max_length=500)
    distribution = models.CharField(max_length=500)
    version = models.CharField(max_length=500)
    command = models.CharField(max_length=1000)
    command_stop = models.CharField(max_length=1000, null=True, blank=True)

    class Meta:
        unique_together = ('family', 'distribution', 'version', 'job')

    def __str__(self):
        return '{} {} {} commands for Job {}'.format(self.family, self.distribution, self.version, self.job)

    @property
    def json(self):
        return {
                'ansible_system': self.family,
                'ansible_distribution': self.distribution,
                'ansible_distribution_version': self.version,
                'command': self.command,
                'command_stop': self.command_stop,
        }


class Statistic(models.Model):
    """Data associated to a Statistic generated by a Job"""

    name = models.CharField(max_length=500)
    job = models.ForeignKey(Job, models.CASCADE, related_name='statistics')
    description = models.TextField(null=True, blank=True)
    frequency = models.TextField(null=True, blank=True)

    class Meta:
        unique_together = ('name', 'job')

    def __str__(self):
        return self.name

    @property
    def json(self):
        return {
                'name': self.name,
                'description': self.description,
                'frequency': self.frequency,
        }


class InstalledJob(models.Model):
    """Data associated to a Job installed on an Agent"""

    agent = models.ForeignKey(
            'Agent', models.CASCADE,
            related_name='installed_jobs')
    job = models.ForeignKey(
            Job, models.CASCADE,
            related_name='installations')
    job_version = models.CharField(max_length=500)
    update_status = models.DateTimeField(null=True, blank=True)
    severity = models.IntegerField(default=1)
    local_severity = models.IntegerField(default=1)
    default_stat_local = models.BooleanField(default=True)
    default_stat_storage = models.BooleanField(default=True)
    default_stat_broadcast = models.BooleanField(default=False)

    class Meta:
        unique_together = ('agent', 'job')

    def __str__(self):
        return '{0.job} installed on {0.agent}'.format(self)

    @property
    def json(self):
        return {
                'name': self.job.name,
                'update_status': self.update_status.astimezone(
                    timezone.get_current_timezone()),
                'severity': self.severity,
                'local_severity': self.local_severity,
                'default_stat_policy': {
                    'local': self.default_stat_local,
                    'storage': self.default_stat_storage,
                    'broadcast': self.default_stat_broadcast,
                },
                'statistic_instances': [stat.json for stat in self.statistics.all()],
        }


class StatisticInstance(models.Model):
    """State of a given Statistic for a specific Installed_Job"""

    stat = models.ForeignKey(
            Statistic, models.CASCADE,
            related_name='instances')
    job = models.ForeignKey(
            InstalledJob, models.CASCADE,
            related_name='statistics')
    local = models.BooleanField(default=True)
    storage = models.BooleanField(default=True)
    broadcast = models.BooleanField(default=False)

    class Meta:
        unique_together = ('stat', 'job')

    def __str__(self):
        return self.stat.name

    def save(self, *args, **kwargs):
        if self.job.job != self.stat.job:
            raise IntegrityError(
                    'Trying to save a StatisticInstance with the '
                    'associated InstalledJob and the associated '
                    'Statistic not referencing the same Job')
        super().save(*args, **kwargs)

    @property
    def json(self):
        return {
                'name': self.stat.name,
                'local': self.local,
                'storage': self.storage,
                'broadcast': self.broadcast,
        }


class JobInstance(models.Model):
    """Data associated to a Job instance"""

    class Status(models.TextChoices):
        SCHEDULED = 'P'
        RUNNING = 'R'
        ERROR = 'E'
        STOPPED = 'S'
        AGENT_UNREACHABLE = 'U'
        NOT_RUNNING = 'NR'
        NOT_SCHEDULED = 'NS'
        UNKNOWN = '?'

    job_name = models.CharField(max_length=500)
    agent_name = models.CharField(max_length=500)
    entity_name = models.CharField(max_length=500)
    agent = models.ForeignKey(
            'Agent', models.SET_NULL,
            null=True, blank=True,
            related_name='+')
    collector = models.ForeignKey(
            'Collector', models.CASCADE,
            related_name='+')
    status = models.CharField(
            max_length=max(map(len, Status.values)),
            choices=Status.choices,
            default=Status.UNKNOWN)
    update_status = models.DateTimeField()
    start_date = models.DateTimeField()
    started_by = models.ForeignKey(
            User, models.CASCADE,
            null=True, blank=True,
            related_name='private_job_instances')
    stop_date = models.DateTimeField(null=True, blank=True)
    periodic = models.BooleanField()
    openbach_function_instance = models.OneToOneField(
            'OpenbachFunctionInstance',
            models.SET_NULL,
            null=True, blank=True,
            related_name='started_job')

    @property
    def is_stopped(self):
        return self.stop_date is not None

    def get_status(self, override_status=None):
        if override_status is None:
            return self.Status(self.status)

        for status in self.Status:
            if status.label == override_status:
                return status
        return self.Status.UNKNOWN

    def set_status(self, status):
        now = timezone.now()
        if status is not self.get_status():
            self.status = status
            self.update_status = now
        if status in {self.Status.SCHEDULED, self.Status.RUNNING}:
            self.stop_date = None
        elif status not in {self.Status.UNKNOWN, self.Status.AGENT_UNREACHABLE}:
            if self.stop_date is None:
                self.stop_date = now
        self.save()

    @property
    def last_status(self):
        now = timezone.now()
        return (now - self.update_status).total_seconds()

    @property
    def scenario_id(self):
        if self.openbach_function_instance is None:
            return 0
        return self.openbach_function_instance.scenario_instance.id

    @property
    def project(self):
        if self.openbach_function_instance is None:
            return
        return self.openbach_function_instance.scenario_instance.scenario.project

    @property
    def start_timestamp(self):
        date = self.start_date
        if date < timezone.now():
            return 'now'
        return int(date.timestamp() * 1000)

    @property
    def arguments(self):
        required_args = self.required_arguments.all()
        optional_flags_only = self.optional_arguments.filter(
                argument__type=ValuesType.NONE_TYPE.value)
        optional_arguments = self.optional_arguments.exclude(
                argument__type=ValuesType.NONE_TYPE.value)

        return list(chain.from_iterable(
                self._format_arguments(
                    used.subcommand.name,
                    required_args.filter(argument__subcommand=used.subcommand),
                    optional_arguments.filter(argument__subcommand=used.subcommand),
                    optional_flags_only.filter(argument__subcommand=used.subcommand))
                for used in self.used_subcommands.select_related('subcommand').order_by('id').all()))

    def _format_arguments(self, name, required, optionals, flags):
        options = {}  # TODO optimize
        for argument in optionals:
            flag = argument.argument.flag
            value = argument.value
            option = options.setdefault(flag, [])
            occurrence = argument.occurrence
            if occurrence == len(option):
                option.append([flag, value])
            else:
                option[occurrence].append(value)
        options_items = map(chain.from_iterable, options.values())

        # TODO: due to https://bugs.python.org/issue9338 we cannot have
        # optional arguments before either required ones or a subcommand name
        # This is not perfect as it won't account for a lack of flags before
        # a subcommand name and situations like (this)[1] can still arise.
        #  [1] https://stackoverflow.com/q/41742205/5069029
        if name is not None:
            yield name
        yield from (argument.value for argument in required)
        yield from chain.from_iterable(options_items)
        yield from (argument.argument.flag for argument in flags)

    def configure(self, arguments, date=None, interval=None):
        """Build the hierarchy of values for this Job Instance arguments"""
        self.start_date = timezone.now()
        if interval is None:
            self.periodic = False
            if date not in (None, 'now'):
                tz = timezone.get_current_timezone()
                self.start_date = datetime.fromtimestamp(date / 1000, tz=tz)
        else:
            self.periodic = True

        # Remove old arguments in case of a restart
        self.required_arguments_values.all().delete()
        self.optional_arguments_values.all().delete()
        self.used_subcommands.all().delete()

        job = Job.objects.get(name=self.job_name)
        self._configure(job, job.subcommands.get(name=None), arguments)

    def _configure(self, job, command, arguments):
        self.used_subcommands.create(subcommand=command)

        for name, arg_values in arguments.items():
            try:
                argument = JobArgument.objects.get(subcommand=command, name=name)
            except JobArgument.DoesNotExist:
                try:
                    subcommand = job.subcommands.get(name=name)
                except SubcommandJobArgument.DoesNotExist:
                    raise KeyError(
                            '\'{}\' argument is not part of the job '
                            '\'{}\''.format(name, job.name))
                else:
                    self._configure(job, subcommand, arg_values)
                    continue

            if hasattr(argument, 'requiredjobargument'):
                JobArgumentValue = RequiredJobArgumentValue
                argument = argument.requiredjobargument
                repeatable = False
            elif hasattr(argument, 'optionaljobargument'):
                JobArgumentValue = OptionalJobArgumentValue
                argument = argument.optionaljobargument
                repeatable = argument.optionaljobargument.repeatable
            else:
                raise ValueError(
                        '\'{}\' argument for the job \'{}\' is neither '
                        'required nor optional'.format(name, job.name))

            if not isinstance(arg_values, list):
                arg_values = [[arg_values]]
            if not isinstance(arg_values[0], list):
                arg_values = [arg_values]

            repeated = len(arg_values)
            if repeated > 1 and not repeatable:
                raise ValueError(
                        '{}: provided {} set of values but argument '
                        'is not repeatable'.format(name, repeated))

            for occurrence, values in enumerate(arg_values):
                count = len(values)
                if not argument.check_count(count):
                    raise ValueError(
                            '{}: provided number of arguments ({}) does not '
                            'match with their expected number ({})'
                            .format(name, count, argument.count_str))
                for value in values:
                    job_argument = JobArgumentValue(argument=argument, job_instance=self)
                    job_argument.check_and_set_value(value)
                    job_argument.occurrence = occurrence
                    job_argument.save()

    def __str__(self):
        agent_address = None
        if self.agent:
            agent_address = self.agent.address
        return 'Job Instance {} of {} installed on {} ({})'.format(
                self.id, self.job_name,
                self.agent_name, agent_address)

    @property
    def required_arguments(self):
        return self.required_arguments_values.select_related('argument')

    @property
    def optional_arguments(self):
        return self.optional_arguments_values.select_related('argument')

    @property
    def json(self):
        arguments = {}
        for argument in chain(self.required_arguments.all(), self.optional_arguments.all()):
            subcommand = argument.argument.subcommand
            name = argument.argument.name
            value = argument.value
            subcommand_storage(subcommand, arguments).setdefault(name, []).append(value)

        tz = timezone.get_current_timezone()
        stop_date = 'Not programmed yet'
        if self.stop_date is not None:
            stop_date = self.stop_date.astimezone(tz)

        agent_address = None
        if self.agent:
            agent_address = self.agent.address

        return {
                'name': self.job_name,
                'agent': agent_address,
                'agent_name': self.agent_name,
                'entity': self.entity_name,
                'id': self.id,
                'arguments': arguments,
                'update_status': self.update_status.astimezone(tz),
                'status': self.get_status().label,
                'start_date': self.start_date.astimezone(tz),
                'stop_date': stop_date,
        }


class SubcommandGroupArgument(models.Model):
    """Data associated to a group of subcommands of a Job"""

    name = models.CharField(max_length=500)
    optional = models.BooleanField(default=False)
    subcommand = models.ForeignKey(
            'SubcommandJobArgument', models.CASCADE,
            related_name='groups')

    class Meta:
        unique_together = ('name', 'subcommand')

    @property
    def json(self):
        return {
                'group_name': self.name,
                'optional': self.optional,
                'choices': [sub.json for sub in self.subcommands.all()],
        }


class SubcommandJobArgument(models.Model):
    """Data associated to a subcommand of a Job"""

    job = models.ForeignKey(Job, models.CASCADE, related_name='subcommands')
    name = models.CharField(max_length=500, null=True, blank=True)
    group = models.ForeignKey(
            SubcommandGroupArgument, models.CASCADE,
            related_name='subcommands', null=True, blank=True)

    class Meta:
        unique_together = ('name', 'job')

    def save(self, *args, **kwargs):
        none_count = sum(arg is None for arg in (self.name, self.group))
        if none_count == 1:
            raise IntegrityError('group and name should be null together or set together')
        elif none_count == 2:
            # Manually enforce unique_together with null names and groups
            qs = SubcommandJobArgument.objects.filter(job=self.job, name=None, group=None)
            if qs.exclude(pk=self.pk).exists():
                raise IntegrityError(
                        'The default subcommand group is already present '
                        'in the database for the Job {}'.format(self.job.name))
        super().save(*args, **kwargs)

    @property
    def json(self):
        description = {
            'required': [arg.requiredjobargument.json for arg in self.required_arguments.order_by('requiredjobargument__rank')],
            'optional': [arg.optionaljobargument.json for arg in self.optional_arguments],
        }

        if self.name is not None:
            description['name'] = self.name

        subcommands = [sub.json for sub in self.groups.all()]
        if subcommands:
            description['subcommands'] = subcommands

        return description

    @property
    def required_arguments(self):
        return self.arguments.filter(requiredjobargument__isnull=False).select_related('requiredjobargument')

    @property
    def optional_arguments(self):
        return self.arguments.filter(optionaljobargument__isnull=False).select_related('optionaljobargument')


class JobArgument(Argument):
    """Data associated to arguments of a Job"""

    subcommand = models.ForeignKey(
            SubcommandJobArgument, models.CASCADE,
            related_name='arguments')
    type = models.CharField(
            max_length=10, choices=ValuesType.choices(),
            default=ValuesType.NONE_TYPE.value)
    count_lower = models.PositiveIntegerField(default=1)
    count_upper = models.PositiveIntegerField(null=True, blank=True)
    password = models.BooleanField(default=False)
    default = models.CharField(max_length=500, null=True, blank=True)

    class Meta:
        unique_together = ('name', 'subcommand')

    def __init__(self, *args, **kwargs):
        if 'count' in kwargs:
            lower, upper = self._count_from_str(kwargs.pop('count'))
            kwargs['count_lower'] = lower
            kwargs['count_upper'] = upper
        super().__init__(*args, **kwargs)

    def check_count(self, count):
        if self.type == ValuesType.NONE_TYPE.value:
            return True

        lower = self.count_lower
        upper = self.count_upper

        if upper is None:
            return count >= lower
        return lower <= count <= upper

    @property
    def count_str(self):
        lower = self.count_lower
        upper = self.count_upper

        if upper is None:
            return '+' if lower else '*'
        elif lower == upper:
            return str(lower)
        else:
            return '{}-{}'.format(lower, upper)

    @count_str.setter
    def count_str(self, count):
        lower, upper = self._count_from_str(count)
        self.count_lower = lower
        self.count_upper = upper

    @staticmethod
    def _count_from_str(count):
        count = str(count)

        if count == '*':
            return 0, None
        elif count == '+':
            return 1, None
        else:
            counts = [int(x) for x in count.split('-')]
            try:
                lower, upper = counts
            except ValueError:
                lower, = counts
                upper = lower
            return lower, upper

    def save(self, *args, **kwargs):
        if self.count_upper is not None and self.count_lower > self.count_upper:
            raise IntegrityError(
                    'When using a range as the count value of the '
                    'argument \'{}\', the second integer should be '
                    'greater than the first one'.format(self.name))
        super().save(*args, **kwargs)

    @property
    def json(self):
        description = {
                'name': self.name,
                'type': self.type,
                'count': self.count_str,
                'description': self.description,
                'password': self.password,
        }

        if self.default is not None:
            description['default'] = self.default

        choices = [choice.value for choice in self.choices.all()]
        if choices:
            description['choices'] = choices

        return description


class ArgumentChoice(models.Model):
    """Choice given for a job's Argument"""

    argument = models.ForeignKey(
            JobArgument, models.CASCADE,
            related_name='choices')
    value = models.CharField(max_length=500)


class RequiredJobArgument(JobArgument):
    """Data associated to an Argument that is required for a Job"""

    rank = models.PositiveIntegerField()

    def save(self, *args, **kwargs):
        # Enforce unique_together using columns of
        # another table (parent class table)
        qs = RequiredJobArgument.objects.filter(
                rank=self.rank,
                subcommand=self.subcommand)
        if qs.exclude(pk=self.pk).exists():
            raise IntegrityError(
                    'A RequiredJobArgument of rank {} is already '
                    'present in the database for the subcommand {}'
                    .format(self.rank, self.subcommand.name))
        super().save(*args, **kwargs)


class OptionalJobArgument(JobArgument):
    """Data associated to an Argument that is optional for a Job"""

    flag = models.CharField(max_length=500)
    repeatable = models.BooleanField(default=False)

    def save(self, *args, **kwargs):
        # Enforce unique_together using columns of
        # another table (parent class table)
        qs = OptionalJobArgument.objects.filter(
                flag=self.flag,
                subcommand=self.subcommand)
        if qs.exclude(pk=self.pk).exists():
            raise IntegrityError(
                    'An OptionalJobArgument using the {} flag is already '
                    'present in the database for the subcommand {}'
                    .format(self.rank, self.subcommand.name))
        super().save(*args, **kwargs)

    @property
    def json(self):
        return {
                **super().json,
                'flag': self.flag,
                'repeatable': self.repeatable,
        }


class RequiredJobArgumentValue(ArgumentValue):
    """Data stored as the value of a Required Argument for a Job"""

    argument = models.ForeignKey(
            RequiredJobArgument,
            models.CASCADE,
            related_name='values')
    job_instance = models.ForeignKey(
            JobInstance, models.CASCADE,
            related_name='required_arguments_values')

    class Meta:
        ordering = ['argument__rank', 'argument_value_id']

    def check_and_set_value(self, value):
        self._check_and_set_value(value, self.argument.type)

    def save(self, *args, **kwargs):
        if self.argument.subcommand.job.name != self.job_instance.job_name:
            raise IntegrityError(
                    'Trying to save a RequiredJobArgumentValue '
                    'with the associated JobInstance and the '
                    'associated job argument not referencing the same Job')
        super().save(*args, **kwargs)


class OptionalJobArgumentValue(ArgumentValue):
    """Data stored as the value of an Optional Argument for a Job"""

    argument = models.ForeignKey(
            OptionalJobArgument,
            models.CASCADE,
            related_name='values')
    job_instance = models.ForeignKey(
            JobInstance, models.CASCADE,
            related_name='optional_arguments_values')
    occurrence = models.PositiveIntegerField(default=0)

    class Meta:
        ordering = ['occurrence', 'argument_value_id']

    def check_and_set_value(self, value):
        arg_type = self.argument.type
        if arg_type == ValuesType.NONE_TYPE.value:
            self.value = ''
        else:
            self._check_and_set_value(value, arg_type)

    def save(self, *args, **kwargs):
        if self.argument.subcommand.job.name != self.job_instance.job_name:
            raise IntegrityError(
                    'Trying to save an OptionalJobArgumentValue '
                    'with the associated JobInstance and the '
                    'associated job argument not referencing the same Job')
        super().save(*args, **kwargs)


class UsedSubcommandArgument(models.Model):
    job_instance = models.ForeignKey(
            JobInstance, models.CASCADE,
            related_name='used_subcommands')
    subcommand = models.ForeignKey(
            SubcommandJobArgument,
            models.CASCADE, related_name='+')
